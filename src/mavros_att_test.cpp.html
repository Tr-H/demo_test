<h1>include <stdlib.h></h1>

<h1>include "ros/ros.h"</h1>

<h1>include "demo<em>test/pos</em>data.h"</h1>

<h1>include "demo<em>test/pos</em>write_data2.h"</h1>

<h1>include "demo<em>test/pos</em>status.h"</h1>

<h1>include "demo<em>test/attitude</em>feedback.h"</h1>

<h1>include "demo<em>test/velocity</em>feedback.h"</h1>

<h1>include "demo<em>test/body</em>attitude.h"</h1>

<h1>include "demo<em>test/position</em>setpoint.h"</h1>

<h1>include <string.h></h1>

<h1>include <math.h></h1>

<h1>include <cstring></h1>

<h1>include <boost/thread.hpp></h1>

<h1>include <fcntl.h></h1>

<h1>include <stdio.h></h1>

<h1>include <unistd.h></h1>

<h1>include <sys/types.h></h1>

<h1>include <termios.h></h1>

<h1>include <stdlib.h></h1>

<h1>include <time.h></h1>

<h1>include <geometry_msgs/PoseStamped.h></h1>

<h1>include <mavros_msgs/CommandBool.h></h1>

<h1>include <mavros_msgs/SetMode.h></h1>

<h1>include <mavros_msgs/State.h></h1>

<h1>include <demo_test/demo_code.h></h1>

<h1>include <std_msgs/Float64.h></h1>

<h1>include "checksum.h"</h1>

<p>std<em>msgs::Float64 global</em>att<em>throttle;
mavros</em>msgs::State current<em>state;
void state</em>cb(const mavros<em>msgs::State::ConstPtr&amp; msg){
    current</em>state = <em>msg;
}
struct Q_att
{
    float q1;
    float q2;
    float q3;
    float q4;
};
struct Q_att from_euler(float roll, float pitch, float yaw) 
{
    double cosPhi_2 = cos(double(roll) / 2.0);
    double sinPhi_2 = sin(double(roll) / 2.0);
    double cosTheta_2 = cos(double(pitch) / 2.0);
    double sinTheta_2 = sin(double(pitch) / 2.0);
    double cosPsi_2 = cos(double(yaw) / 2.0);
    double sinPsi_2 = sin(double(yaw) / 2.0);
    struct Q_att Q_local;
    /</em> operations executed in double to avoid loss of precision through
     * consecutive multiplications. Result stored as float.
     <em>/
    Q_local.q1 = static_cast<float>(cosPhi_2 * cosTheta_2 * cosPsi_2 + sinPhi_2 * sinTheta_2 * sinPsi_2);
    Q_local.q2 = static_cast<float>(sinPhi_2 * cosTheta_2 * cosPsi_2 - cosPhi_2 * sinTheta_2 * sinPsi_2);
    Q_local.q3 = static_cast<float>(cosPhi_2 * sinTheta_2 * cosPsi_2 + sinPhi_2 * cosTheta_2 * sinPsi_2);
    Q_local.q4 = static_cast<float>(cosPhi_2 * cosTheta_2 * sinPsi_2 - sinPhi_2 * sinTheta_2 * cosPsi_2);
    return Q_local;
}
int main(int argc, char *</em>argv)
{
    ros::init(argc, argv, "mavros<em>att</em>test");
    ros::NodeHandle nh;</p>

<pre><code>ros::Subscriber state_sub = nh.subscribe&lt;mavros_msgs::State&gt;
    ("mavros/state", 10, state_cb);
//ros::Publisher local_pos_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;
//       ("mavros/setpoint_position/local", 10);
ros::Publisher local_att_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;
    ("mavros/setpoint_attitude/attitude", 10);
ros::Publisher local_thrust_pub = nh.advertise&lt;std_msgs::Float64&gt;
    ("mavros/setpoint_attitude/att_throttle", 10);
ros::ServiceClient arming_client = nh.serviceClient&lt;mavros_msgs::CommandBool&gt;
    ("mavros/cmd/arming");
ros::ServiceClient set_mode_client = nh.serviceClient&lt;mavros_msgs::SetMode&gt;
    ("mavros/set_mode");

//the setpoint publishing rate MUST be faster than 2Hz
ros::Rate rate(20.0);

// wait for FCU connection
while(ros::ok() &amp;&amp; current_state.connected){
    ros::spinOnce();
    rate.sleep();
}
struct Q_att Q_local_sp;
float pitch_set = 0.0f;
float roll_set = 0.0f;
float yaw_set = 0.0f;
Q_local_sp = from_euler(roll_set,pitch_set,yaw_set);
geometry_msgs::PoseStamped att_sp;
att_sp.pose.orientation.x = Q_local_sp.q2;
att_sp.pose.orientation.y = Q_local_sp.q3;
att_sp.pose.orientation.z = Q_local_sp.q4;
att_sp.pose.orientation.w = Q_local_sp.q1;
global_att_throttle.data = 0.3f;
//send a few setpoints before starting
for(int i = 100; ros::ok() &amp;&amp; i &gt; 0; --i){
    ros::spinOnce();
    local_att_pub.publish(att_sp); 
    local_thrust_pub.publish(global_att_throttle);
    rate.sleep();
}

mavros_msgs::SetMode offb_set_mode;
offb_set_mode.request.custom_mode = "OFFBOARD";

mavros_msgs::CommandBool arm_cmd;
arm_cmd.request.value = true;

ros::Time last_request = ros::Time::now();

while(ros::ok()){
    if( current_state.mode != "OFFBOARD" &amp;&amp;
            (ros::Time::now() - last_request &gt; ros::Duration(5.0))){
        if( set_mode_client.call(offb_set_mode) &amp;&amp;
                offb_set_mode.response.success){
            ROS_INFO("Offboard enabled");
        }
        last_request = ros::Time::now();
    } else {
        if( !current_state.armed &amp;&amp;
                (ros::Time::now() - last_request &gt; ros::Duration(5.0))){
            if( arming_client.call(arm_cmd) &amp;&amp;
                    arm_cmd.response.success){
                ROS_INFO("Vehicle armed");
            }
            last_request = ros::Time::now();
        }
    }
    ROS_INFO("p: %.2f r: %.2f y: %.2f th: %.2f",roll_set,pitch_set,yaw_set,global_att_throttle.data);
    Q_local_sp = from_euler(roll_set,pitch_set,yaw_set);
    att_sp.pose.orientation.x = Q_local_sp.q2;
    att_sp.pose.orientation.y = Q_local_sp.q3;
    att_sp.pose.orientation.z = Q_local_sp.q4;
    att_sp.pose.orientation.w = Q_local_sp.q1;
    global_att_throttle.data = 0.5f;

    ros::spinOnce();
    rate.sleep();
}

return 0;
</code></pre>

<p>}</p>
